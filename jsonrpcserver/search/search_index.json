{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Process incoming JSON-RPC requests in Python.</p> <p>Jump to: GitHub | Community Wiki</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>Methods</li> <li>Dispatch</li> <li>Async</li> <li>Faq</li> <li>Examples</li> </ul>"},{"location":"async/","title":"Async","text":"<p>Async dispatch is supported.</p> <pre><code>from jsonrpcserver import method, Success, async_dispatch\n\n@method\nasync def ping() -&gt; Result:\n    return Success(\"pong\")\n\nawait async_dispatch('{\"jsonrpc\": \"2.0\", \"method\": \"ping\", \"id\": 1}')\n</code></pre> <p>Some reasons to use this:</p> <ul> <li>Use it with an asynchronous protocol like sockets or message queues.</li> <li><code>await</code> long-running functions from your method.</li> <li>Batch requests are dispatched concurrently.</li> </ul>"},{"location":"async/#notifications","title":"Notifications","text":"<p>Notifications are requests without an <code>id</code>. We should not respond to notifications, so jsonrpcserver gives an empty string to signify there is no response.</p> <pre><code>&gt;&gt;&gt; await async_dispatch('{\"jsonrpc\": \"2.0\", \"method\": \"ping\"}')\n''\n</code></pre> <p>If the response is an empty string, don't send it.</p> <pre><code>if response := dispatch(request):\n    send(response)\n</code></pre> <p>\ud83d\udcdd A synchronous protocol like HTTP requires a response no matter what, so we can send back the empty string. However with async protocols, we have the choice of responding or not.</p>"},{"location":"dispatch/","title":"Dispatch","text":"<p>The <code>dispatch</code> function takes a JSON-RPC request, calls the appropriate method and gives a JSON-RPC response.</p> <pre><code>&gt;&gt;&gt; dispatch('{\"jsonrpc\": \"2.0\", \"method\": \"ping\", \"id\": 1}')\n'{\"jsonrpc\": \"2.0\", \"result\": \"pong\", \"id\": 1}'\n</code></pre> <p>See how dispatch is used in different frameworks.</p>"},{"location":"dispatch/#optional-parameters","title":"Optional parameters","text":""},{"location":"dispatch/#methods","title":"methods","text":"<p>This lets you specify a group of methods to dispatch to. It's an alternative to using the <code>@method</code> decorator. The value should be a dict mapping function names to functions.</p> <pre><code>def ping():\n    return Success(\"pong\")\n\ndispatch(request, methods={\"ping\": ping})\n</code></pre> <p>Default is <code>global_methods</code>, which is an internal dict populated by the <code>@method</code> decorator.</p>"},{"location":"dispatch/#context","title":"context","text":"<p>If specified, this will be the first argument to all methods.</p> <pre><code>@method\ndef greet(context, name):\n    return Success(context + \" \" + name)\n\n&gt;&gt;&gt; dispatch('{\"jsonrpc\": \"2.0\", \"method\": \"greet\", \"params\": [\"Beau\"], \"id\": 1}', context=\"Hello\")\n'{\"jsonrpc\": \"2.0\", \"result\": \"Hello Beau\", \"id\": 1}'\n</code></pre>"},{"location":"dispatch/#deserializer","title":"deserializer","text":"<p>A function that parses the request string. Default is <code>json.loads</code>.</p> <pre><code>dispatch(request, deserializer=ujson.loads)\n</code></pre>"},{"location":"dispatch/#serializer","title":"serializer","text":"<p>A function that serializes the response string. Default is <code>json.dumps</code>.</p> <pre><code>dispatch(request, serializer=ujson.dumps)\n</code></pre>"},{"location":"dispatch/#validator","title":"validator","text":"<p>A function that validates the request once the json has been parsed. The function should raise an exception (any exception) if the request doesn't match the JSON-RPC spec. Default is <code>default_validator</code> which validates the request against a schema.</p>"},{"location":"examples/","title":"Examples","text":"<p>Examples have moved to the Community Wiki.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-to-disable-schema-validation","title":"How to disable schema validation?","text":"<p>Validating requests is costly - roughly 40% of dispatching time is spent on schema validation. If you know the incoming requests are valid, you can disable the validation for better performance.</p> <pre><code>dispatch(request, validator=lambda _: None)\n</code></pre>"},{"location":"faq/#which-http-status-code-to-respond-with","title":"Which HTTP status code to respond with?","text":"<p>I suggest:</p> <pre><code>200 if response else 204\n</code></pre> <p>If the request was a notification, <code>dispatch</code> will give you an empty string. So since there's no http body, use status code 204 - no content.</p>"},{"location":"faq/#how-to-rename-a-method","title":"How to rename a method","text":"<p>Use <code>@method(name=\"new_name\")</code>.</p> <p>Or use the dispatch function's methods parameter.</p>"},{"location":"faq/#how-to-get-the-response-in-other-forms","title":"How to get the response in other forms?","text":"<p>Instead of <code>dispatch</code>, use:</p> <ul> <li><code>dispatch_to_serializable</code> to get the response as a dict.</li> <li><code>dispatch_to_response</code> to get the response as a namedtuple (either a   <code>SuccessResponse</code> or <code>ErrorResponse</code>, these are defined in   response.py).</li> </ul> <p>For these functions, if the request was a batch, you'll get a list of responses. If the request was a notification, you'll get <code>None</code>.</p>"},{"location":"installation/","title":"Installation","text":"<p>Install with Pip:</p> <pre><code>pip install jsonrpcserver\n</code></pre>"},{"location":"methods/","title":"Methods","text":"<p>Methods are functions that can be called by a JSON-RPC request. To write one, decorate a function with <code>@method</code>:</p> <pre><code>from jsonrpcserver import method, Result, Success, Error\n\n@method\ndef ping() -&gt; Result:\n    return Success(\"pong\")\n</code></pre> <p>If you don't need to respond with any value simply <code>return Success()</code>.</p>"},{"location":"methods/#responses","title":"Responses","text":"<p>Methods return either <code>Success</code> or <code>Error</code>. These are the JSON-RPC response objects (excluding the <code>jsonrpc</code> and <code>id</code> parts). <code>Error</code> takes a code, message, and optionally 'data'.</p> <pre><code>@method\ndef test() -&gt; Result:\n    return Error(1, \"There was a problem\")\n</code></pre> <p>\ud83d\udcdd Alternatively, raise a <code>JsonRpcError</code>, which takes the same arguments as <code>Error</code>.</p>"},{"location":"methods/#parameters","title":"Parameters","text":"<p>Methods can accept arguments.</p> <pre><code>@method\ndef hello(name: str) -&gt; Result:\n    return Success(\"Hello \" + name)\n</code></pre> <p>Testing it:</p> <pre><code>$ curl -X POST http://localhost:5000 -d '{\"jsonrpc\": \"2.0\", \"method\": \"hello\", \"params\": [\"Beau\"], \"id\": 1}'\n{\"jsonrpc\": \"2.0\", \"result\": \"Hello Beau\", \"id\": 1}\n</code></pre>"},{"location":"methods/#invalid-params","title":"Invalid params","text":"<p>A common error response is invalid params. The JSON-RPC error code for this is -32602. A shortcut, InvalidParams, is included so you don't need to remember that.</p> <pre><code>from jsonrpcserver import method, Result, InvalidParams, Success, dispatch\n\n@method\ndef within_range(num: int) -&gt; Result:\n    if num not in range(1, 5):\n        return InvalidParams(\"Value must be 1-5\")\n    return Success()\n</code></pre> <p>This is the same as saying</p> <pre><code>return Error(-32602, \"Invalid params\", \"Value must be 1-5\")\n</code></pre>"}]}