{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>Jump to: GitHub | Developer Wiki</p> <p>SuperStack is a minimal, modular backend powered by PostgreSQL \u2014 perfect for indie developers, SaaS builders, and teams who want full control without the bloat.</p> <p>Spin up a fully working backend in seconds. Just clone, run, and start building.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#whats-next","title":"\ud83d\udcda What's next?","text":"<p>\ud83d\udc49 Getting Started \u2013 a guide to installing SuperStack and launching the stack.</p>"},{"location":"deploying/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployment is simple and portable. Here's how to deploy it to a remote server.</p> <p>A goal of SuperStack is that only <code>compose.yaml</code> should be required on the remote server.</p>"},{"location":"deploying/#1-prepare-your-images","title":"\u2705 1. Prepare your Images","text":"<p>For services that are built (they have a <code>build:</code> section in <code>compose.yaml</code>), add your own container repository image URIs (e.g. your Docker Hub or GitHub Container Registry account), for example:</p> compose.yaml<pre><code>caddy:\n  build:\n    context: ./caddy\n  image: ghcr.io/youruser/yourapp-caddy:0.1.0\n\npostgres:\n  build:\n    context: ./postgres\n  image: ghcr.io/youruser/yourapp-postgres:0.1.0\n</code></pre>"},{"location":"deploying/#2-build-and-push-your-images","title":"\ud83d\udee0\ufe0f 2. Build and Push your Images","text":"<p>Build your images locally and push to your registry:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploying/#3-deploy-the-compose-file","title":"\ud83d\udce6 3. Deploy the Compose File","text":"<p>Copy <code>compose.yaml</code> to the server:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploying/#4-set-secrets","title":"4. Set Secrets","text":"<p>The stack needs your secrets (passwords, keys, etc.). There are a few options:</p> <ol> <li>Put secrets in a <code>.env</code> file on the server. Convenient but Less secure. Be    sure to <code>chmod 600 .env</code>.</li> <li>Set environment variables in the the <code>docker compose</code> command. Inconvenient.    Be sure to disable shell history.</li> <li>Use environment injection in your CI/CD.</li> </ol>"},{"location":"deploying/#5-launch-your-stack","title":"\ud83d\ude80 5. Launch your Stack","text":"<p>SSH into your server and bring up the stack:</p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>That\u2019s it \u2014 your backend is live.</p> <p>If this is the first time bringing up your stack, the migrations will run automatically. Subsequently, to upgrade your app you should:</p> <pre><code>docker compose pull\ndocker compose up -d\ndocker compose exec postgres migrate\n</code></pre>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"Your browser does not support the video tag.  <p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-get-superstack","title":"1. Get SuperStack","text":""},{"location":"gettingstarted/#option-1-use-the-template-easiest","title":"Option 1: Use the Template (Easiest)","text":"<p>Click Use this template and create a new repository (e.g. <code>myapp-backend</code>) on GitHub.</p> <p>Clone it to your machine:</p> <pre><code>git clone https://github.com/yourname/myapp-backend.git\ncd myapp-backend\n</code></pre>"},{"location":"gettingstarted/#option-2-clone-and-track-upstream-advanced","title":"Option 2: Clone and Track Upstream (Advanced)","text":"<p>If you want to keep SuperStack\u2019s Git history and pull upstream changes later, clone SuperStack:</p> <pre><code>git clone https://github.com/explodinglabs/superstack.git myapp-backend\ncd myapp-backend\n</code></pre> <p>Create your own repo, then:</p> <pre><code>git remote rename origin upstream\ngit remote add origin https://github.com/yourname/myapp-backend.git\ngit push -u origin main\n</code></pre> <p>You can now pull upstream changes with:</p> <pre><code>git pull upstream main\n</code></pre>"},{"location":"gettingstarted/#2-configure-environment-variables","title":"2. Configure Environment Variables","text":"<p>Copy the example environment file:</p> <pre><code>cp example.env .env\n</code></pre> <p>This <code>.env</code> file is used to set secrets, passwords, keys, etc.</p> <p>\u26a0\ufe0f Never store secrets in version control.</p>"},{"location":"gettingstarted/#3-start-the-stack","title":"3. Start the Stack","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is live.</p>"},{"location":"gettingstarted/#what-just-happened","title":"\ud83e\udde9 What Just Happened?","text":"<p>SuperStack automatically:</p> <ol> <li>Starts a fresh Postgres database</li> <li>Applies initial migrations</li> <li>Launches PostgREST</li> <li>Serves everything through Caddy</li> </ol> <p>\ud83d\udca1 Only Caddy exposes a port \u2013 all services are routed through it.</p>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Create your database schema with migrations \ud83d\udc49 Deploy to a remote environment</p>"},{"location":"structure/","title":"Build Your App","text":""},{"location":"structure/#project-structure","title":"Project Structure","text":"<pre><code>\ud83d\udcc1 bin/                  \u2192 Helper scripts (e.g. wrappers for CLI tools)\n\ud83d\udcc1 caddy/                \u2192 Caddy configuration\n\ud83d\udcc1 docs/                 \u2192 Markdown files for SuperStack documentation\n\ud83d\udcc1 postgres/             \u2192 Postgres configuration and SQL migrations\n\ud83d\udcc4 compose.yaml          \u2192 Main Docker Compose config\n\ud83d\udcc4 compose.override.yaml \u2192 Optional local overrides (development only)\n\ud83d\udcc4 example.env           \u2192 Example environment variables \u2014 copy to `.env`\n\ud83d\udcc4 LICENSE               \u2192 License file (MIT)\n\ud83d\udcc4 logo.png              \u2192 SuperStack logo for README/docs\n\ud83d\udcc4 README.md             \u2192 Overview and quick start for the repository\n</code></pre>"},{"location":"zerodowntime/","title":"Zerodowntime","text":"<p>This page is a work in progress \u2013 Beau</p> <p>Blue/Green deployment runs two stacks side-by-side: one live, one idle. You deploy to the idle stack, test it, and when ready, swap roles. It gives near-zero downtime and easy rollback.</p> <p></p> <p>Blue/Green adds some complexity because where before there was just \"the stack\", now there is:</p> <ol> <li>A <code>blue</code> stack</li> <li>A <code>green</code> stack</li> <li>A proxy to direct traffic</li> <li>An external Postgres container.</li> </ol>"},{"location":"zerodowntime/#1-caddy-adjustments","title":"1. Caddy Adjustments","text":""},{"location":"zerodowntime/#name-the-caddy-containers","title":"Name the Caddy containers","text":"<p>Naming the Caddy containers <code>blue_caddy</code> and <code>green_caddy</code> allows the proxy to direct traffic to the correct stacks:</p> compose.yaml<pre><code>caddy:\n  container_name: ${STACK_NAME}_caddy\n</code></pre>"},{"location":"zerodowntime/#remove-exposed-ports","title":"Remove exposed ports","text":"<p>We'll no longer expose ports in our stacks. Instead a proxy will sit in front of the two stacks, proxying to them.</p> <p>Remove the Caddy service's <code>ports:</code> section in <code>compose.yaml</code>.</p>"},{"location":"zerodowntime/#serve-http-only-in-the-stacks","title":"Serve HTTP-only in the stacks","text":"<p>Set <code>CADDY_SITE_ADDRESS</code> to only <code>:80</code>, removing <code>:443</code>, leaving TLS termination to the proxy:</p> compose.yaml<pre><code>caddy:\n  environment:\n    CADDY_SITE_ADDRESS: :80\n</code></pre>"},{"location":"zerodowntime/#2-postgres","title":"2. Postgres","text":"<p>In regular SuperStack, Postgres comes up with the stack. But now we're bringing up two stacks, we can't have two Postgres containers both simultaneously accessing the same shared volume. We need a single Postgres container, separate from the stacks.</p> <p>Add a profile to the Postgres service:</p> compose.yaml<pre><code>postgres:\n  profiles: [\"db\"]\n</code></pre> <p>Add it to the Compose file:</p> compose.yaml<pre><code>networks:\n  postgres:\n    name: postgres\n    external: true\n</code></pre> <p>Then in services that need database access (such as PostgREST):</p> compose.yaml<pre><code>networks:\n  - postgres\n</code></pre> <p>Move Postgres out of compose.yaml into a shared-compose.yaml, adding the <code>shared</code> network:</p>"},{"location":"zerodowntime/#3-volumes","title":"3. Volumes","text":"<p>To share data between the two stacks (uploads, etc.), give volumes explicit names:</p> compose.yaml<pre><code>volumes:\n  user_data:\n    name: user-data\n</code></pre>"},{"location":"zerodowntime/#4-bring-up-two-stacks","title":"4. Bring up two Stacks","text":"<p>Deploying is the same as before, but now we're deploying the idle stack. For this example, <code>green</code> is idle so that's the one we're deploying.</p> <p>Create <code>blue</code> and <code>green</code> directories on the server and copy <code>compose.yaml</code> into the idle stack's directory:</p> <pre><code>scp compose.yaml youruser@yourserver:green/compose.yaml\n</code></pre> <p>Shell into the server and bring up the idle stack:</p> <pre><code>cd green\ndocker compose pull\nSTACK_NAME=green docker compose up -d\n</code></pre> <p>Docker will use the directory name <code>green</code> as the project name, creating different containers, volumes and networks than the <code>blue</code> stack.</p>"},{"location":"zerodowntime/#5-add-a-proxy","title":"5. Add a Proxy","text":"<p>The proxy is a single container that binds ports <code>80</code> and <code>443</code> on the server and routes requests into either the Blue or Green stack.</p> <p>On the server, create a simple <code>Caddyfile</code>:</p> caddy/Caddyfile<pre><code>api.myapp.com {\n  reverse_proxy blue_caddy:80\n}\n</code></pre> <p>Optionally, point a second hostname to the idle stack for testing.</p> <p>The front proxy manages TLS, so give it a persistent volume for certificates:</p> <pre><code>docker volume create caddy_data\n</code></pre> <p>Start the proxy, attaching it to both networks \u2013 this requires both stacks to be up first, so the networks exist:</p> <pre><code>docker run -d \\\n  --name front-proxy \\\n  -p 80:80 -p 443:443 \\\n  -v ./caddy:/etc/caddy \\\n  -v caddy_data:/data \\\n  --network blue_default \\\n  --network green_default \\\n  caddy:2\n</code></pre>"},{"location":"zerodowntime/#6-upgrading","title":"6. Upgrading","text":""},{"location":"zerodowntime/#flip-traffic","title":"Flip traffic","text":"<p>Point traffic to the <code>green</code> stack:</p> Caddyfile<pre><code>api.myapp.com {\n  reverse_proxy green_caddy:80\n}\n</code></pre> <p>Reload the proxy's config:</p> <pre><code>docker exec front-proxy caddy reload\n</code></pre> <p>Cutover is instant. Green is now live, and Blue is the idle stack.</p> <p>And rollback is simple: flip the <code>Caddyfile</code> back and <code>caddy reload</code> again.</p>"},{"location":"zerodowntime/#github-actions","title":"Github Actions","text":"<p>Here's a workflow for B/G deploys:</p> Click to expand .github/workflows/ci.yaml<pre><code>name: Deploy\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Start SSH agent\n        uses: webfactory/ssh-agent@v0.9.0\n        with:\n          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}\n\n      - name: Get the idle stack\n        id: idle\n        run: |\n          ACTIVE=$(ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \\\n            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \\\n            'cat active_stack 2&gt;/dev/null || echo blue')\n\n          if [ \"$ACTIVE\" = \"blue\" ]; then\n            echo \"IDLE=green\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"IDLE=blue\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n          echo \"ACTIVE=$ACTIVE\" &gt;&gt; $GITHUB_OUTPUT\n\n      - name: Copy compose.yaml to idle stack\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          port: 22\n          key: ${{ secrets.VPS_SSH_KEY }}\n          source: \"compose.yaml\"\n          target: \"${{ steps.idle.outputs.IDLE }}/\"\n\n      - name: Deploy idle stack\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          envs: GHCR_PAT\n          script: |\n            set -euo pipefail\n            echo \"${{ steps.idle.outputs.ACTIVE }}\" &gt; active_stack\n            cd ${{ steps.idle.outputs.IDLE }}\n            echo \"$GHCR_PAT\" | docker login ghcr.io -u \"${{ github.actor }}\" --password-stdin\n            DOCKER_CLIENT_TIMEOUT=300 COMPOSE_HTTP_TIMEOUT=300 docker compose pull -q\n            STACK_NAME=${{ steps.idle.outputs.IDLE }} docker compose up -d\n        env:\n          GHCR_PAT: ${{ secrets.GHCR_PAT }}\n</code></pre>  If you want to auto-flip between blue and green, add this extra task:  <pre><code>- name: Flip traffic\n  uses: appleboy/ssh-action@v1.0.3\n  with:\n    host: ${{ secrets.VPS_HOST }}\n    username: ${{ secrets.VPS_USER }}\n    key: ${{ secrets.VPS_SSH_KEY }}\n    script: |\n      if [ \"${{ steps.idle.outputs.IDLE }}\" = \"blue\" ]; then\n        sed -i 's/green_caddy/blue_caddy/g' caddy/Caddyfile\n      else\n        sed -i 's/blue_caddy/green_caddy/g' caddy/Caddyfile\n      fi\n      docker exec front-proxy caddy reload --config /etc/caddy/Caddyfile\n      echo \"${{ steps.idle.outputs.IDLE }}\" &gt; active_stack\n</code></pre>"}]}