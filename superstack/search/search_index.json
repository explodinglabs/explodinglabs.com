{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>Jump to: GitHub | SuperStack Wiki</p> <p>SuperStack is a minimal, modular backend powered by Docker \u2014 perfect for indie developers, SaaS builders, and teams who want full control without the bloat.</p> <p>Spin up a fully working backend in seconds. Just clone, run, and start building.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#get-started","title":"\ud83d\udcda Get Started","text":"<p>\ud83d\udc49 Proceed to Getting Started \u2013 a guide to installing SuperStack and launching the stack.</p>"},{"location":"advanced/","title":"\u2699\ufe0f Advanced Deployments","text":"<p>By default, SuperStack runs as a single project that's upgraded in place.</p> <p>While this is simple, it has some trade-offs:</p> <ul> <li>Some downtime during upgrades</li> <li>No way to test a new version while another is live (blue/green)</li> <li>No quick rollback once upgraded</li> </ul> <p>When your app is ready for production, you can enable a simple traffic routing proxy to eliminate these issues.</p>"},{"location":"advanced/#how-it-works","title":"\ud83e\udded How It Works","text":"<p>The \"proxy\" is a tiny service already included with SuperStack that sits in front of your app. Its responsibilities:</p> <ul> <li>Route traffic to the correct app</li> <li>Simplify switching between versions</li> <li>Handle TLS termination</li> </ul> <pre><code>flowchart TD\n    FormerApp[\"Former App\"]\n    Proxy[\"Traffic Router\"]\n    Proxy --&gt; LiveApp[\"Live App\"]\n    NextApp[\"Next App\"]\n</code></pre> <p>Normally the app exposes ports directly, but in this advanced mode, the proxy owns the ports, and apps connect to its Docker network.</p>"},{"location":"advanced/#tasks","title":"\ud83d\udd04 Tasks","text":"<ol> <li>Enable the proxy project (included in SuperStack)</li> <li>Stop exposing ports in the app</li> <li>Instead, connect to the proxy's Docker network</li> <li>The proxy will listen on <code>:80</code> and <code>:443</code></li> </ol> <p>The application still manages api routes, auth, etc.</p>"},{"location":"advanced/#1-start-the-proxy","title":"\ud83e\uddf1 1. Start the Proxy","text":"<p>For consistent environments, use the proxy in all environments, including development.</p> <p>A <code>proxy</code> project already exists in your SuperStack project.</p> <p>First, stop your app to release the ports:</p> <pre><code>cd app\ndocker compose down\n</code></pre> <p>Start the proxy:</p> <pre><code>cd ../proxy\ndocker compose up -d\n</code></pre>"},{"location":"advanced/#2-adjust-the-application","title":"\u2699\ufe0f 2. Adjust the Application","text":"<p>Remove the <code>ports:</code> from the app, and connect it to the proxy's network by adding these lines:</p> app/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    environment:\n      CADDY_SITE_ADDRESS: \":80\"\n    networks:\n      default:\n      proxy_default:\n        aliases:\n          - ${COMPOSE_PROJECT_NAME}_caddy\n\nnetworks:\n  proxy_default:\n    external: true\n</code></pre> <p>Also remove the <code>ports:</code> and <code>CADDY_SITE_ADDRESS</code> in <code>app/compose.override.yaml</code>.</p> <p>What's Changed?</p> <ol> <li>Exposed ports were removed</li> <li><code>CADDY_SITE_ADDRESS</code> now listens internally on port <code>:80</code></li> <li>The app joins the proxy's network so traffic can be routed to it</li> <li>A container alias (<code>_caddy</code>) allows the proxy to target this service    reliably</li> </ol> <p>Bring up the app:</p> <pre><code>docker compose up -d\n</code></pre> <p>Test with:</p> <pre><code>$ curl http://localhost:8000/healthcheck\nOK\n</code></pre> <p>Commit these changes \u2013 your app is now proxy-ready.</p>"},{"location":"advanced/#3-deploying-to-a-remote-server","title":"\ud83d\ude80 3. Deploying to a Remote Server","text":"<p>The proxy is deployed once (usually manually). After that, each app version is deployed separately into its own directory.</p> <ol> <li>For each deployment, bring up a new app (e.g. <code>app/&lt;commit&gt;</code>)</li> <li>Test the new app while the current one remains live</li> <li>Flip traffic in the proxy to point to the new app</li> <li>Tear down the old one when ready</li> </ol> <pre><code>proxy/\n  compose.yaml\napp/\n  a/\n    compose.yaml\n    .env\n  b/\n    compose.yaml\n    .env\n</code></pre>"},{"location":"advanced/#step-1-deploy-the-proxy","title":"Step 1. Deploy the Proxy","text":"<p>Before deploying, build and push your own proxy image by adding an <code>image:</code> line to the Compose file:</p> proxy/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-proxy:0.1.0\n</code></pre> <p>Build and push it:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre> <p>Create a proxy directory on the server:</p> <pre><code>mkdir proxy\n</code></pre> <p>Copy the proxy's Compose file:</p> <pre><code>scp proxy/compose.yaml app-backend:proxy/\n</code></pre> <p>Start the proxy:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"advanced/#step-2-deploy-a-new-app-version","title":"Step 2. Deploy a new App version","text":"<p>Deploy your app into a new directory (e.g. <code>app/b/</code>):</p> <p>Important: Give it a unique directory name every time. Here we use 'b' for simplicity, but I recommend using the commit hash.</p> <pre><code>mkdir app/b\n</code></pre> <p>Copy <code>compose.yaml</code> (and secrets) there:</p> <pre><code>scp compose.yaml yourserver:app/b/\n</code></pre> <p>Start the app on the server:</p> <pre><code>cd app/b\ndocker compose up -d\n</code></pre> <p>Verify the new app is healthy before switching traffic:</p> <pre><code>$ docker compose exec -T caddy curl -fsS http://caddy:80/healthz\nOK\n</code></pre>"},{"location":"advanced/#4-route-traffic","title":"\ud83d\udd01 4. Route Traffic","text":""},{"location":"advanced/#option-1-use-caddys-rest-api","title":"Option 1: Use Caddy's REST API","text":"<p>Caddy's configuration can be adjusted via HTTP using its REST API.</p> <p>Since the app was brought up in a directory named <code>b</code>, the app's Caddy service was given the alias <code>b_caddy</code>.</p> <p>Redirect all traffic to <code>b_caddy</code>:</p> <pre><code>cd proxy\ndocker compose exec caddy curl -X PATCH -d '\"b_caddy:80\"' \\\n  http://localhost:2019/config/apps/http/servers/srv0/routes/0/handle/0/upstreams/0/dial\n</code></pre> <p>Traffic now points to the new stack.</p>"},{"location":"advanced/#option-2-mount-a-caddyfile","title":"Option 2: Mount a Caddyfile","text":"<p>Create a simple Caddyfile on the server, such as:</p> proxy/caddy/Caddyfile<pre><code>{$CADDY_SITE_ADDRESS}\n\nreverse_proxy b_caddy:80\n</code></pre> <p>Mount it into the proxy's Caddy container:</p> proxy/compose.yaml<pre><code>services:\n  caddy:\n    volumes:\n      - ./caddy:/etc/caddy\n</code></pre> <p>Recreate the container:</p> <pre><code>cd proxy\ndocker compose up -d --force-recreate caddy\n</code></pre> <p>After that, to re-route traffic, simply change the app service name in <code>proxy/caddy/Caddyfile</code> and reload the proxy's configuration:</p> <pre><code>docker compose exec caddy caddy reload --config /etc/caddy/Caddyfile\n</code></pre>"},{"location":"advanced/#github-actions-example","title":"\u26a1 GitHub Actions Example","text":"<p>Add this Github Actions workflow to automate deployments:</p> Show full workflow .github/workflows/ci.yaml<pre><code>name: Deploy\n\non:\n  push:\n    branches:\n      - prod\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Copy compose.yaml from repository to deployment dir\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          source: \"app/compose.yaml\"\n          target: \"app/${{ github.sha }}/\"\n          strip_components: 1\n\n      - name: Deploy with Docker Compose\n        uses: appleboy/ssh-action@v1.0.3\n        env:\n          GHCR_PAT: ${{ secrets.GHCR_PAT }}\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          envs: GHCR_PAT\n          script: |\n            set -euo pipefail\n            cp .env app/${{ github.sha }}/\n            cd app/${{ github.sha }}\n\n            # Pull images\n            echo \"$GHCR_PAT\" | docker login ghcr.io --username \"${{ github.actor }}\" --password-stdin\n            DOCKER_CLIENT_TIMEOUT=300 COMPOSE_HTTP_TIMEOUT=300 docker compose pull --quiet\n\n            # Bring up stack and run healthchecks\n            trap 'docker compose down' ERR\n            docker compose up --detach\n            docker compose exec -T caddy curl -fsS http://caddy:80/healthz\n            # Add more healthchecks here\n            # docker compose exec -T caddy curl -fsS http://api:8080/healthz\n            # docker compose exec -T caddy curl -fsS http://postgrest:3000/\n\n      - name: Flip traffic\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          script: |\n            set -euo pipefail\n            cd proxy/caddy\n\n            # Grab the formerly-active stack so we can stop the containers later\n            OLD_HASH=$(grep '^reverse_proxy' Caddyfile | awk '{print $2}' | cut -d_ -f1)\n\n            # Flip traffic\n            sed -i \"s|^reverse_proxy .*:80|reverse_proxy ${{ github.sha }}_caddy:80|\" Caddyfile\n            docker compose exec caddy caddy reload --config /etc/caddy/Caddyfile\n\n            # Stop the old stack\n            cd ~/app/$OLD_HASH\n            docker compose down\n\n            # Add to deploy.log\n            mkdir -p /var/log/sku-generator\n            echo \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") ${{ github.sha }}\" &gt;&gt; /var/log/sku-generator/deploy.log\n</code></pre>"},{"location":"deploy/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployments are simple, consistent, and portable.</p> <p>The goal is that only <code>compose.yaml</code> and secrets need to exist on the remote server.</p>"},{"location":"deploy/#1-build-your-images","title":"\ud83e\uddf1 1. Build Your Images","text":"<p>If a service has a <code>build:</code> section, add your own image name and version tag:</p> app/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-caddy:0.1.0\n</code></pre> <p>Build and push your images:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploy/#2-copy-to-server","title":"\ud83d\udce6 2. Copy to Server","text":"<p>Copy your <code>compose.yaml</code> to the remote host:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploy/#3-set-secrets","title":"3. Set Secrets","text":"<p>Your app will need credentials such as database passwords or API keys. Choose one of these approaches:</p> <ol> <li><code>.env</code> file \u2014 simply place a <code>.env</code> file alongside your <code>compose.yaml</code>.    Be sure to <code>chmod 600 .env</code>.</li> <li>Environment variables \u2014 pass secrets directly to the command line.</li> <li>CI/CD injection \u2014 good for automated pipelines.</li> </ol>"},{"location":"deploy/#3-launch-the-app","title":"\ud83d\ude80 3. Launch the App","text":"<p>Start the application on the server:</p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Your backend is now live. \ud83d\ude80</p>"},{"location":"deploy/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>If you want zero-downtime deployments, rollback support, or blue-green testing, continue to Advanced Deployments.</p>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"<p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-get-superstack","title":"1. Get SuperStack","text":"<p>Click Use this template and create a new repository (e.g. <code>myapp-backend</code>) on GitHub.</p> <p>Clone it to your machine:</p> <pre><code>git clone https://github.com/yourname/myapp-backend.git\ncd myapp-backend\n</code></pre>"},{"location":"gettingstarted/#2-start-the-app","title":"2. Start the App","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is ready for development.</p> <p>Test it with:</p> <pre><code>$ curl http://localhost:8000/healthz\nOK\n</code></pre>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Add services by following the Wiki \ud83d\udc49 Deploy to a remote environment</p>"}]}