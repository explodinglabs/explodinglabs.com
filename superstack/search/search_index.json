{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>Jump to: GitHub | Developer Wiki</p> <p>SuperStack is a minimal, modular backend powered by Docker \u2014 perfect for indie developers, SaaS builders, and teams who want full control without the bloat.</p> <p>Spin up a fully working backend in seconds. Just clone, run, and start building.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#whats-next","title":"\ud83d\udcda What's next?","text":"<p>\ud83d\udc49 Getting Started \u2013 a guide to installing SuperStack and launching the stack.</p>"},{"location":"advanced/","title":"\u2699\ufe0f Advanced Deployments","text":"<p>By default, SuperStack runs as a single project that's upgraded in place.</p> <p>While this is simple, it has some trade-offs:</p> <ul> <li>Some downtime during upgrades</li> <li>No way to test a new version while another is live (blue/green)</li> <li>No quick rollback once upgraded</li> </ul> <p>When your app is ready for production, consider adding a traffic-switcher in front it.</p>"},{"location":"advanced/#how-it-works","title":"\ud83e\udded How It Works","text":"<p>Instead of directly exposing ports from the app, you add a small proxy project that sits in front of it.</p> <p>The proxy\u2019s job is to:</p> <ul> <li>Route incoming traffic to the active app stack</li> <li>Make it easy to flip traffic between app versions</li> <li>Terminate TLS</li> </ul> <pre><code>flowchart TD\n    Proxy[\"Traffic Router\"]\n    Proxy --&gt; LiveApp[\"Live App\"]\n    NextApp[\"Next App\"]\n</code></pre>"},{"location":"advanced/#deployment-flow","title":"\ud83d\udd04 Deployment Flow","text":"<ol> <li>Stop exposing ports in the app project \u2014 only the proxy will listen on :80 and :443.</li> <li>Add a proxy project that runs Caddy (or another gateway).</li> <li>Each time you deploy, bring up a new app stack, connected to the proxy\u2019s    network.</li> <li>Test the new stack while the old one is still live.</li> <li>Flip traffic in the proxy to point to the new stack.</li> <li>Tear down the old one when ready.</li> </ol> <p>Ok, we need to make some changes to the repository.</p>"},{"location":"advanced/#1-adjust-the-application","title":"1. Adjust the Application","text":"<p>Remove the app's exposed ports, and connect to the proxy's network:</p> app/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    environment:\n      CADDY_SITE_ADDRESS: \":80\"\n    networks:\n      default:\n      proxy_default:\n        aliases:\n          - ${COMPOSE_PROJECT_NAME}_caddy\n\nnetworks:\n  proxy_default:\n    external: true\n</code></pre> <p>What's changed?</p> <ol> <li>The exposed ports were removed.</li> <li>Caddy's site address has changed to <code>:80</code> (The application layer no longer    handles TLS).</li> <li>We connect to the proxy's network, so the proxy can direct traffic to the    app.</li> <li>A container alias was added. This alias allows the proxy to target this    container, while still allowing Docker to manage the container name.</li> </ol> <p>The <code>CADDY_SITE_ADDRESS</code> environment variable can be removed from the override file.</p>"},{"location":"advanced/#2-start-a-new-proxy-project","title":"2. Start a new <code>proxy</code> project","text":"<p>From the root of the repository, create a new <code>proxy</code> project:</p> <pre><code>mkdir proxy\n</code></pre> <p>Give it a Compose file:</p> proxy/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - caddy_data:/data\n    environment:\n      CADDY_SITE_ADDRESS: api.myapp.com\n\nvolumes:\n  caddy_data:\n    name: caddy-data # Persistent volume for certificates\n</code></pre> <p>Add development overrides:</p> proxy/compose.override.yaml<pre><code># Development overrides\n\nservices:\n  caddy:\n    ports:\n      - \"8000:80\"\n    environment:\n      CADDY_SITE_ADDRESS: :80\n</code></pre> <p>Configure Caddy:</p> <pre><code>mkdir proxy/caddy\n</code></pre> proxy/caddy/Caddyfile<pre><code>{$CADDY_SITE_ADDRESS}\n\nreverse_proxy app_caddy:80\n</code></pre> <p>Add a Dockerfile:</p> proxy/caddy/Dockerfile<pre><code>FROM caddy:2\n\nCOPY Caddyfile /etc/caddy/Caddyfile\n</code></pre>"},{"location":"advanced/#start-the-services","title":"Start the services","text":"<p>Start the proxy first, then the app which connects to its network.</p> <pre><code>cd proxy &amp;&amp; docker compose up -d\ncd ../app &amp;&amp; docker compose up -d\n</code></pre>"},{"location":"advanced/#deploying","title":"Deploying","text":"<pre><code>proxy/\n  compose.yaml\napp/\n  a/\n    compose.yaml\n    .env\n  b/\n    compose.yaml\n    .env\n</code></pre> <p>The proxy is deployed once.</p> <p>On the server, create a proxy directory:</p> <pre><code>mkdir proxy\n</code></pre> <p>Copy your Compose file to the server:</p> <pre><code>scp proxy/compose.yaml app-backend:proxy/\n</code></pre> <p>You might also point a second hostname to an idle stack for testing.</p>"},{"location":"advanced/#deploy-the-app","title":"Deploy the app","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"advanced/#flip-traffic","title":"Flip traffic","text":"<pre><code>cd proxy\ndocker compose exec caddy curl -X PATCH -d '\"newapp_caddy:80\"' \\\n  http://localhost:2019/config/apps/http/servers/srv0/routes/0/handle/0/upstreams/0/dial\n</code></pre>"},{"location":"advanced/#github-actions-workflow","title":"Github Actions Workflow","text":".github/workflows/ci.yaml<pre><code>name: Deploy\n\non:\n  push:\n    branches:\n      - prod\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Copy compose.yaml from repository to deployment dir\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          source: \"app/compose.yaml\"\n          target: \"app/${{ github.sha }}/\"\n          strip_components: 1\n\n      - name: Deploy with Docker Compose\n        uses: appleboy/ssh-action@v1.0.3\n        env:\n          GHCR_PAT: ${{ secrets.GHCR_PAT }}\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          envs: GHCR_PAT\n          script: |\n            set -euo pipefail\n            cp .env app/${{ github.sha }}/\n            cd app/${{ github.sha }}\n\n            # Pull images\n            echo \"$GHCR_PAT\" | docker login ghcr.io --username \"${{ github.actor }}\" --password-stdin\n            DOCKER_CLIENT_TIMEOUT=300 COMPOSE_HTTP_TIMEOUT=300 docker compose pull --quiet\n\n            # Bring up stack and run healthchecks\n            trap 'docker compose down' ERR\n            docker compose up --detach\n            docker compose exec -T caddy curl -fsS http://caddy:80/healthcheck\n            # Add more healthchecks here\n            # docker compose exec -T caddy curl -fsS http://api:8080/healthcheck\n            # docker compose exec -T caddy curl -fsS http://postgrest:3000/\n\n      - name: Flip traffic\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          script: |\n            set -euo pipefail\n            cd proxy/caddy\n\n            # Grab the formerly-active stack so we can stop the containers later\n            OLD_HASH=$(grep '^reverse_proxy' Caddyfile | awk '{print $2}' | cut -d_ -f1)\n\n            # Flip traffic\n            sed -i \"s|^reverse_proxy .*:80|reverse_proxy ${{ github.sha }}_caddy:80|\" Caddyfile\n            docker compose exec caddy caddy reload --config /etc/caddy/Caddyfile\n\n            # Stop the old stack\n            cd ~/app/$OLD_HASH\n            docker compose down\n\n            # Add to deploy.log\n            mkdir -p /var/log/sku-generator\n            echo \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") ${{ github.sha }}\" &gt;&gt; /var/log/sku-generator/deploy.log\n</code></pre>"},{"location":"deploy/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployments are simple, consistent, and portable. The goal is that only <code>compose.yaml</code> and secrets need to exist on the remote server.</p>"},{"location":"deploy/#1-build-your-images","title":"\ud83e\uddf1 1. Build Your Images","text":"<p>If a service has a <code>build:</code> section, add your own image name and version tag:</p> compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-caddy:0.1.0\n</code></pre> <p>Build and push your images:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploy/#2-copy-to-server","title":"\ud83d\udce6 2. Copy to Server","text":"<p>Copy your <code>compose.yaml</code> to the remote host:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploy/#3-set-secrets","title":"3. Set Secrets","text":"<p>Your app will need credentials such as database passwords or API keys. Choose one of these approaches:</p> <ol> <li><code>.env</code> file \u2014 simply place a <code>.env</code> file alongside your <code>compose.yaml</code>.    Be sure to <code>chmod 600 .env</code>.</li> <li>Environment variables \u2014 pass secrets directly to the command line.</li> <li>CI/CD injection \u2014 good for automated pipelines.</li> </ol>"},{"location":"deploy/#3-launch-the-app","title":"\ud83d\ude80 3. Launch the App","text":"<p>Start the application on the server:</p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Your backend is now live. \ud83d\ude80</p>"},{"location":"deploy/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>If you want zero-downtime deployments, rollback support, or blue-green testing, continue to Advanced Deployments.</p>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"<p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-get-superstack","title":"1. Get SuperStack","text":""},{"location":"gettingstarted/#option-1-use-the-template-easiest","title":"Option 1: Use the Template (Easiest)","text":"<p>Click Use this template and create a new repository (e.g. <code>myapp-backend</code>) on GitHub.</p> <p>Clone it to your machine:</p> <pre><code>git clone https://github.com/yourname/myapp-backend.git\ncd myapp-backend\n</code></pre>"},{"location":"gettingstarted/#option-2-clone-and-track-upstream-advanced","title":"Option 2: Clone and Track Upstream (Advanced)","text":"<p>If you want to keep SuperStack\u2019s Git history and pull upstream changes later, clone SuperStack:</p> <pre><code>git clone https://github.com/explodinglabs/superstack.git myapp-backend\ncd myapp-backend\n</code></pre> <p>Create your own repo, then:</p> <pre><code>git remote rename origin upstream\ngit remote add origin https://github.com/yourname/myapp-backend.git\ngit push -u origin main\n</code></pre> <p>You can now pull upstream changes with:</p> <pre><code>git pull upstream main\n</code></pre>"},{"location":"gettingstarted/#2-configure-environment-variables","title":"2. Configure Environment Variables","text":"<p>Copy the example environment file:</p> <pre><code>cd app\ncp example.env .env\n</code></pre> <p>The <code>.env</code> file is used to set secrets, passwords, keys, etc.</p> <p>\u26a0\ufe0f Never store secrets in version control.</p>"},{"location":"gettingstarted/#3-start-the-app","title":"3. Start the App","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is live.</p> <p>Test it with:</p> <pre><code>$ curl http://localhost:8000/healthcheck\nOK\n</code></pre>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Deploy to a remote environment</p>"}]}