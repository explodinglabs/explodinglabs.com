{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>Jump to: GitHub | Developer Wiki</p> <p>SuperStack is a minimal, modular backend powered by Docker \u2014 perfect for indie developers, SaaS builders, and teams who want full control without the bloat.</p> <p>Spin up a fully working backend in seconds. Just clone, run, and start building.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#whats-next","title":"\ud83d\udcda What's next?","text":"<p>\ud83d\udc49 Getting Started \u2013 a guide to installing SuperStack and launching the stack.</p>"},{"location":"advanced/","title":"Advanced Deployments","text":"<p>The standard SuperStack replaces the stack in place.</p> <ul> <li>There's some downtime while upgrading.</li> <li>You can't test one app while another is live (blue/green)</li> <li>Once an app is upgrade, you can't rollback.</li> </ul> <p>Once your app is ready for production, consider adding a traffic-switcher in front of your app.</p> <p>How it works:</p> <ul> <li>We stop exposing ports in the <code>app</code> project.</li> <li>A new <code>proxy</code> project is added, with ports open.</li> <li>It's purpose is to direct traffic to the right application.</li> <li>Apps are deployed completely separate to the live one.</li> </ul> <p>This way, environments are ephemeral, immutable and idempotent.</p> <p>The directory structure looks like:</p> <pre><code>proxy/\n  compose.yaml\napp/\n  a/\n    compose.yaml\n    .env\n  b/\n    compose.yaml\n    .env\n</code></pre>"},{"location":"advanced/#1-create-a-new-project","title":"1. Create a new project","text":"<p>From the root of the repository, create a new <code>proxy</code> project:</p> <pre><code>mkdir proxy\n</code></pre> <p>Add a compose file:</p> proxy/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - caddy_data:/data\n    environment:\n      CADDY_SITE_ADDRESS: api.myapp.com\n\nvolumes:\n  caddy_data:\n    name: caddy-data # The proxy manages TLS, so give it a persistent volume for certificates\n</code></pre> proxy/compose.override.yaml<pre><code># Development overrides\n\nservices:\n  caddy:\n    ports:\n      - \"8000:80\"\n    environment:\n      CADDY_SITE_ADDRESS: :80\n</code></pre> proxy/caddy/Caddyfile<pre><code>{$CADDY_SITE_ADDRESS}\n\nreverse_proxy app_caddy:80\n</code></pre>"},{"location":"advanced/#2-update-the-application","title":"2. Update the Application","text":"<p>Remove the app's exposed ports, and connect to the proxy's network:</p> <p>```yaml title=\"app/compose.yaml\" hl_lines=\"6-13,15-17\" services:   caddy:     build:       context: ./caddy     environment:       CADDY_SITE_ADDRESS: \":80\"     networks:       default:       # This alias allows the proxy to target this container, while still       # allowing Docker to manage the container name       proxy_default:         aliases:           - ${COMPOSE_PROJECT_NAME}_caddy</p> <p>networks:   proxy_default:     external: true <pre><code>```yaml title=\"app/compose.override.yaml\"\n# Development overrides\n\nservices:\n  caddy:\n    volumes:\n      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro\n</code></pre></p>"},{"location":"advanced/#deploy-the-proxy","title":"Deploy the Proxy","text":"<p>The proxy is only deployed once.</p> <p>On the server, create a proxy directory:</p> <pre><code>mkdir proxy\n</code></pre> <p>Back on local, copy your Compose file to the server:</p> <pre><code>scp proxy/compose.yaml app-backend:proxy/\n</code></pre> <p>You might also point a second hostname to an idle stack for testing.</p>"},{"location":"advanced/#deploy-the-app","title":"Deploy the app","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"advanced/#flip-traffic","title":"Flip traffic","text":"<pre><code>cd proxy\ndocker compose exec caddy curl -X PATCH -d '\"newapp_caddy:80\"' \\\n  http://localhost:2019/config/apps/http/servers/srv0/routes/0/handle/0/upstreams/0/dial\n</code></pre>"},{"location":"advanced/#github-actions-workflow","title":"Github Actions Workflow","text":".github/workflows/ci.yaml<pre><code>name: Deploy\n\non:\n  push:\n    branches:\n      - prod\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Copy compose.yaml from repository to deployment dir\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          source: \"app/compose.yaml\"\n          target: \"app/${{ github.sha }}/\"\n          strip_components: 1\n\n      - name: Deploy with Docker Compose\n        uses: appleboy/ssh-action@v1.0.3\n        env:\n          GHCR_PAT: ${{ secrets.GHCR_PAT }}\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          envs: GHCR_PAT\n          script: |\n            set -euo pipefail\n            cp .env app/${{ github.sha }}/\n            cd app/${{ github.sha }}\n\n            # Pull images\n            echo \"$GHCR_PAT\" | docker login ghcr.io --username \"${{ github.actor }}\" --password-stdin\n            DOCKER_CLIENT_TIMEOUT=300 COMPOSE_HTTP_TIMEOUT=300 docker compose pull --quiet\n\n            # Bring up stack and run healthchecks\n            trap 'docker compose down' ERR\n            docker compose up --detach\n            docker compose exec -T caddy curl -fsS http://caddy:80/healthcheck\n            # Add more healthchecks here\n            # docker compose exec -T caddy curl -fsS http://api:8080/healthcheck\n            # docker compose exec -T caddy curl -fsS http://postgrest:3000/\n\n      - name: Flip traffic\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          script: |\n            set -euo pipefail\n            cd proxy/caddy\n\n            # Grab the formerly-active stack so we can stop the containers later\n            OLD_HASH=$(grep '^reverse_proxy' Caddyfile | awk '{print $2}' | cut -d_ -f1)\n\n            # Flip traffic\n            sed -i \"s|^reverse_proxy .*:80|reverse_proxy ${{ github.sha }}_caddy:80|\" Caddyfile\n            docker compose exec caddy caddy reload --config /etc/caddy/Caddyfile\n\n            # Stop the old stack\n            cd ~/app/$OLD_HASH\n            docker compose down\n\n            # Add to deploy.log\n            mkdir -p /var/log/sku-generator\n            echo \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") ${{ github.sha }}\" &gt;&gt; /var/log/sku-generator/deploy.log\n</code></pre>"},{"location":"deploy/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployments are simple, consistent, and portable. The goal is that only <code>compose.yaml</code> and secrets need to exist on the remote server.</p>"},{"location":"deploy/#1-build-your-images","title":"\ud83e\uddf1 1. Build Your Images","text":"<p>If a service has a <code>build:</code> section, add your own image name and version tag:</p> compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-caddy:0.1.0\n</code></pre> <p>Build and push your images:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploy/#2-copy-to-server","title":"\ud83d\udce6 2. Copy to Server","text":"<p>Copy your <code>compose.yaml</code> to the remote host:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploy/#3-set-secrets","title":"3. Set Secrets","text":"<p>Your app will need credentials such as database passwords or API keys. Choose one of these approaches:</p> <ol> <li><code>.env</code> file \u2014 simply place a <code>.env</code> file alongside your <code>compose.yaml</code>.    Be sure to <code>chmod 600 .env</code>.</li> <li>Environment variables \u2014 pass secrets directly to the command line.</li> <li>CI/CD injection \u2014 good for automated pipelines.</li> </ol>"},{"location":"deploy/#3-launch-the-app","title":"\ud83d\ude80 3. Launch the App","text":"<p>Start the application on the server:</p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Your backend is now live. \ud83d\ude80</p>"},{"location":"deploy/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>If you want zero-downtime deployments, rollback support, or blue-green testing, continue to Advanced Deployments.</p>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"<p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-get-superstack","title":"1. Get SuperStack","text":""},{"location":"gettingstarted/#option-1-use-the-template-easiest","title":"Option 1: Use the Template (Easiest)","text":"<p>Click Use this template and create a new repository (e.g. <code>myapp-backend</code>) on GitHub.</p> <p>Clone it to your machine:</p> <pre><code>git clone https://github.com/yourname/myapp-backend.git\ncd myapp-backend\n</code></pre>"},{"location":"gettingstarted/#option-2-clone-and-track-upstream-advanced","title":"Option 2: Clone and Track Upstream (Advanced)","text":"<p>If you want to keep SuperStack\u2019s Git history and pull upstream changes later, clone SuperStack:</p> <pre><code>git clone https://github.com/explodinglabs/superstack.git myapp-backend\ncd myapp-backend\n</code></pre> <p>Create your own repo, then:</p> <pre><code>git remote rename origin upstream\ngit remote add origin https://github.com/yourname/myapp-backend.git\ngit push -u origin main\n</code></pre> <p>You can now pull upstream changes with:</p> <pre><code>git pull upstream main\n</code></pre>"},{"location":"gettingstarted/#2-configure-environment-variables","title":"2. Configure Environment Variables","text":"<p>Copy the example environment file:</p> <pre><code>cd app\ncp example.env .env\n</code></pre> <p>The <code>.env</code> file is used to set secrets, passwords, keys, etc.</p> <p>\u26a0\ufe0f Never store secrets in version control.</p>"},{"location":"gettingstarted/#3-start-the-app","title":"3. Start the App","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is live.</p> <p>Test it with:</p> <pre><code>$ curl http://localhost:8000/healthcheck\nOK\n</code></pre>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Deploy to a remote environment</p>"}]}