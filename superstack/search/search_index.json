{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#superstack","title":"SuperStack","text":"<p>Jump to: GitHub | Developer Wiki</p> <p>SuperStack is a minimal, modular backend powered by Docker \u2014 perfect for indie developers, SaaS builders, and teams who want full control without the bloat.</p> <p>Spin up a fully working backend in seconds. Just clone, run, and start building.</p>"},{"location":"#what-can-i-do-with-superstack","title":"\ud83d\ude80 What Can I Do with SuperStack?","text":"<p>It's perfect for:</p> <ul> <li>\ud83e\uddf1 Building SaaS apps</li> <li>\ud83d\udcbb Running multiple stacks</li> <li>\ud83d\udce6 Easy database migrations</li> <li>\ud83d\udd27 Customizing your toolchain</li> </ul> <p>Everything runs inside Docker and routes through a single exposed port (via Caddy), making it easy to develop locally or deploy remotely.</p>"},{"location":"#get-started","title":"\ud83d\udcda Get Started","text":"<p>\ud83d\udc49 Proceed to Getting Started \u2013 a guide to installing SuperStack and launching the stack.</p>"},{"location":"advanced/","title":"\u2699\ufe0f Advanced Deployments","text":"<p>By default, SuperStack runs as a single project that's upgraded in place.</p> <p>While this is simple, it has some trade-offs:</p> <ul> <li>Some downtime during upgrades</li> <li>No way to test a new version while another is live (blue/green)</li> <li>No quick rollback once upgraded</li> </ul> <p>When your app is ready for production, you can enable a traffic-router in to eliminate downtime, enable blue/green testing and easy rollbacks.</p>"},{"location":"advanced/#how-it-works","title":"\ud83e\udded How It Works","text":"<p>The traffic router is a lightweight proxy project (already included with SuperStack) that sits in front of your app. Its responsibilities:</p> <ul> <li>Route traffic to the active app stack</li> <li>Simplify switching between versions</li> <li>Handle TLS termination</li> </ul> <pre><code>flowchart TD\n    Proxy[\"Traffic Router\"]\n    Proxy --&gt; LiveApp[\"Live App\"]\n    NextApp[\"Next App\"]\n</code></pre> <p>In standard mode, the app exposes ports directly. In advanced mode, the proxy owns the ports, and apps connect to it internally over Docker networks.</p>"},{"location":"advanced/#deployment-flow","title":"\ud83d\udd04 Deployment Flow","text":"<ol> <li>Stop exposing ports in the app project \u2014 only the proxy will listen on <code>:80</code>    and <code>:443</code>.</li> <li>Enable the proxy project (included in the repository).</li> <li>For each deployment, bring up a new app stack (e.g. <code>app/&lt;commit&gt;</code>),    connected to the proxy\u2019s network.</li> <li>Test the new app while the current one remains live.</li> <li>Flip traffic in the proxy to point to the new app.</li> <li>Tear down the old one when ready.</li> </ol>"},{"location":"advanced/#1-start-the-proxy","title":"\ud83e\uddf1 1. Start the Proxy","text":"<p>A <code>proxy</code> project already exists in your SuperStack project.</p> <p>For consistent environments, use the proxy in all environments including development.</p> <p>Start it:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"advanced/#2-adjust-the-application","title":"\u2699\ufe0f 2. Adjust the Application","text":"<p>Remove the app's exposed ports and connect it to the proxy's network:</p> app/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    environment:\n      CADDY_SITE_ADDRESS: \":80\"\n    networks:\n      default:\n      proxy_default:\n        aliases:\n          - ${COMPOSE_PROJECT_NAME}_caddy\n\nnetworks:\n  proxy_default:\n    external: true\n</code></pre> <p>What's Changed?</p> <ol> <li>Exposed ports were removed.</li> <li><code>CADDY_SITE_ADDRESS</code> now listens internally on port <code>:80</code>.</li> <li>The app joins the proxy's network so traffic can be routed to it.</li> <li>A container alias (<code>_caddy</code>) lets the proxy target this service reliably.</li> </ol> <p>You can also remove the <code>CADDY_SITE_ADDRESS</code> override in <code>compose.override.yaml</code>.</p> <p>Recreate the app's Caddy container:</p> <pre><code>docker compose up -d --force-recreate caddy\n</code></pre> <p>Commit these changes \u2013 your app is now \"proxy-ready\".</p>"},{"location":"advanced/#3-deploying","title":"\ud83d\ude80 3. Deploying","text":"<p>The proxy is deployed once (usually manually), and each app is deployed separately into its own directory.</p> <pre><code>proxy/\n  compose.yaml\napp/\n  a/\n    compose.yaml\n    .env\n  b/\n    compose.yaml\n    .env\n</code></pre> <p>Before deploying, build and push your own proxy image by adding an image name to the Compose file:</p> proxy/compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-proxy:0.1.0\n</code></pre> <p>Build and push it:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre> <p>Create a proxy directory on the server:</p> <pre><code>mkdir proxy\n</code></pre> <p>Copy the proxy's Compose file:</p> <pre><code>scp proxy/compose.yaml app-backend:proxy/\n</code></pre> <p>Start the proxy:</p> <p>docker compose up -d</p>"},{"location":"advanced/#4-deploy-the-new-app-stack","title":"\ud83c\udd95 4. Deploy the New App Stack","text":"<p>Deploy your app into a new directory (e.g. <code>b/</code>):</p> <pre><code>scp compose.yaml yourserver:app/b/\n</code></pre> <p>Start it on the server:</p> <pre><code>cd app/b\ndocker compose up -d\n</code></pre> <p>Optionally, verify it's healthy before switching traffic:</p> <pre><code>docker compose exec -T caddy curl -fsS http://caddy:80/healthz\n</code></pre>"},{"location":"advanced/#5-flip-traffic","title":"\ud83d\udd01 5. Flip Traffic","text":"<pre><code>cd proxy\ndocker compose exec caddy curl -X PATCH -d '\"newapp_caddy:80\"' \\\n  http://localhost:2019/config/apps/http/servers/srv0/routes/0/handle/0/upstreams/0/dial\n</code></pre> <p>Traffic now points to the new stack.</p>"},{"location":"advanced/#github-actions-example","title":"\u26a1 GitHub Actions Example","text":"Show full workflow .github/workflows/ci.yaml<pre><code>name: Deploy\n\non:\n  push:\n    branches:\n      - prod\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Copy compose.yaml from repository to deployment dir\n        uses: appleboy/scp-action@master\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          source: \"app/compose.yaml\"\n          target: \"app/${{ github.sha }}/\"\n          strip_components: 1\n\n      - name: Deploy with Docker Compose\n        uses: appleboy/ssh-action@v1.0.3\n        env:\n          GHCR_PAT: ${{ secrets.GHCR_PAT }}\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          envs: GHCR_PAT\n          script: |\n            set -euo pipefail\n            cp .env app/${{ github.sha }}/\n            cd app/${{ github.sha }}\n\n            # Pull images\n            echo \"$GHCR_PAT\" | docker login ghcr.io --username \"${{ github.actor }}\" --password-stdin\n            DOCKER_CLIENT_TIMEOUT=300 COMPOSE_HTTP_TIMEOUT=300 docker compose pull --quiet\n\n            # Bring up stack and run healthchecks\n            trap 'docker compose down' ERR\n            docker compose up --detach\n            docker compose exec -T caddy curl -fsS http://caddy:80/healthz\n            # Add more healthchecks here\n            # docker compose exec -T caddy curl -fsS http://api:8080/healthz\n            # docker compose exec -T caddy curl -fsS http://postgrest:3000/\n\n      - name: Flip traffic\n        uses: appleboy/ssh-action@v1.0.3\n        with:\n          host: ${{ secrets.VPS_HOST }}\n          username: ${{ secrets.VPS_USER }}\n          key: ${{ secrets.VPS_SSH_KEY }}\n          script: |\n            set -euo pipefail\n            cd proxy/caddy\n\n            # Grab the formerly-active stack so we can stop the containers later\n            OLD_HASH=$(grep '^reverse_proxy' Caddyfile | awk '{print $2}' | cut -d_ -f1)\n\n            # Flip traffic\n            sed -i \"s|^reverse_proxy .*:80|reverse_proxy ${{ github.sha }}_caddy:80|\" Caddyfile\n            docker compose exec caddy caddy reload --config /etc/caddy/Caddyfile\n\n            # Stop the old stack\n            cd ~/app/$OLD_HASH\n            docker compose down\n\n            # Add to deploy.log\n            mkdir -p /var/log/sku-generator\n            echo \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") ${{ github.sha }}\" &gt;&gt; /var/log/sku-generator/deploy.log\n</code></pre>"},{"location":"deploy/","title":"\u2601\ufe0f Deploying to Remote Environments","text":"<p>SuperStack is Docker-native, so deployments are simple, consistent, and portable.</p> <p>The goal is that only <code>compose.yaml</code> and secrets need to exist on the remote server.</p>"},{"location":"deploy/#1-build-your-images","title":"\ud83e\uddf1 1. Build Your Images","text":"<p>If a service has a <code>build:</code> section, add your own image name and version tag:</p> compose.yaml<pre><code>services:\n  caddy:\n    build:\n      context: ./caddy\n    image: ghcr.io/youruser/yourapp-caddy:0.1.0\n</code></pre> <p>Build and push your images:</p> <pre><code>docker compose build\ndocker compose push\n</code></pre>"},{"location":"deploy/#2-copy-to-server","title":"\ud83d\udce6 2. Copy to Server","text":"<p>Copy your <code>compose.yaml</code> to the remote host:</p> <pre><code>scp compose.yaml youruser@yourserver:\n</code></pre>"},{"location":"deploy/#3-set-secrets","title":"3. Set Secrets","text":"<p>Your app will need credentials such as database passwords or API keys. Choose one of these approaches:</p> <ol> <li><code>.env</code> file \u2014 simply place a <code>.env</code> file alongside your <code>compose.yaml</code>.    Be sure to <code>chmod 600 .env</code>.</li> <li>Environment variables \u2014 pass secrets directly to the command line.</li> <li>CI/CD injection \u2014 good for automated pipelines.</li> </ol>"},{"location":"deploy/#3-launch-the-app","title":"\ud83d\ude80 3. Launch the App","text":"<p>Start the application on the server:</p> <pre><code>docker compose pull\ndocker compose up -d\n</code></pre> <p>Your backend is now live. \ud83d\ude80</p>"},{"location":"deploy/#next-steps","title":"\ud83e\udded Next Steps","text":"<p>If you want zero-downtime deployments, rollback support, or blue-green testing, continue to Advanced Deployments.</p>"},{"location":"gettingstarted/","title":"\ud83d\ude80 Getting Started","text":"<p>SuperStack uses Docker, so make sure Docker is installed before you begin.</p>"},{"location":"gettingstarted/#1-get-superstack","title":"1. Get SuperStack","text":"<p>Click Use this template and create a new repository (e.g. <code>myapp-backend</code>) on GitHub.</p> <p>Clone it to your machine:</p> <pre><code>git clone https://github.com/yourname/myapp-backend.git\ncd myapp-backend\n</code></pre>"},{"location":"gettingstarted/#2-create-environment-file","title":"2. Create Environment File","text":"<p>Copy the example environment file:</p> <pre><code>cd app\ncp example.env .env\n</code></pre> <p>The <code>.env</code> file is used to set secrets, passwords, keys, etc.</p> <p>\u26a0\ufe0f Never store secrets in version control.</p>"},{"location":"gettingstarted/#3-start-the-app","title":"3. Start the App","text":"<pre><code>docker compose up -d\n</code></pre> <p>That's it \u2013 your backend is ready for development.</p> <p>Test it with:</p> <pre><code>$ curl http://localhost:8000/healthz\nOK\n</code></pre>"},{"location":"gettingstarted/#whats-next","title":"\u2795 What's Next?","text":"<p>\ud83d\udc49 Add services by following the Wiki \ud83d\udc49 Deploy to a remote environment</p>"}]}